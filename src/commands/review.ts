/**
 * Handler for the 'review' command - now supports both V1 and V2 workflows.
 */
import { PrismaClient } from '@prisma/client';
import { getAppWithConfig } from '../graph/workflow';
import { GitHubMethod } from '../index';
import { v4 as uuidv4 } from 'uuid';
import ora from 'ora';
import chalk from 'chalk';
import fs from 'fs';
import path from 'path';

/**
 * Generates a comprehensive markdown report from the review state
 */
const generateMarkdownReport = (state: any, taskId: string, prUrl: string): string => {
  const timestamp = new Date().toISOString();
  const prDetails = state.pr_details || {};
  const analyzedFiles = state.analyzed_files || {};
  const fileCount = Object.keys(analyzedFiles).length;
  
  // Extract owner/repo from URL for cleaner display
  const urlMatch = prUrl.match(/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/);
  const owner = urlMatch ? urlMatch[1] : 'unknown';
  const repo = urlMatch ? urlMatch[2] : 'unknown';
  const prNumber = urlMatch ? urlMatch[3] : 'unknown';
  
  let markdown = `# 📊 Hikmapr PR Review Report

## 📋 Pull Request Information

| Field | Value |
|-------|-------|
| **Repository** | \`${owner}/${repo}\` |
| **PR Number** | #${prNumber} |
| **PR Title** | ${prDetails.title || 'No title'} |
| **PR URL** | [${prUrl}](${prUrl}) |
| **Review Date** | ${new Date(timestamp).toLocaleString()} |
| **Task ID** | \`${taskId}\` |
| **Files Analyzed** | ${fileCount} |

## 📝 PR Description

${prDetails.body || '*No description provided*'}

---

## 🔍 File Analysis Summary

`;

  // Add individual file analyses
  if (fileCount > 0) {
    markdown += `### Files Reviewed (${fileCount})\n\n`;
    
    for (const [fileName, analysis] of Object.entries(analyzedFiles)) {
      markdown += `#### 📁 \`${fileName}\`\n\n`;
      markdown += `${analysis || '*No analysis available*'}\n\n`;
      markdown += `---\n\n`;
    }
  } else {
    markdown += `*No files were analyzed*\n\n`;
  }

  // Add final report
  markdown += `## 🎯 Overall Assessment\n\n`;
  markdown += `${state.final_report || '*No final report generated*'}\n\n`;

  // Add footer
  markdown += `---\n\n`;
  markdown += `*Report generated by [Hikmapr](https://github.com/foyzulkarim/hikma-pr) on ${new Date(timestamp).toLocaleString()}*\n`;
  
  return markdown;
};

/**
 * Saves the markdown report to a file
 */
const saveMarkdownReport = (markdown: string, prUrl: string, taskId: string): string => {
  // Create reports directory if it doesn't exist
  const reportsDir = path.join(process.cwd(), 'reports');
  if (!fs.existsSync(reportsDir)) {
    fs.mkdirSync(reportsDir, { recursive: true });
  }
  
  // Generate filename based on repo and PR number with full timestamp
  const urlMatch = prUrl.match(/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/);
  const owner = urlMatch ? urlMatch[1] : 'unknown';
  const repo = urlMatch ? urlMatch[2] : 'unknown';
  const prNumber = urlMatch ? urlMatch[3] : 'unknown';
  
  // Create a detailed timestamp: YYYY-MM-DD-HHMMSS
  const now = new Date();
  const date = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS
  const timestamp = `${date}-${time}`;
  
  const filename = `${owner}-${repo}-PR${prNumber}-${timestamp}-${taskId.slice(0, 8)}.md`;
  const filepath = path.join(reportsDir, filename);
  
  // Write the file
  fs.writeFileSync(filepath, markdown, 'utf8');
  
  return filepath;
};

export const reviewCommandHandler = async (prUrl: string, prisma: PrismaClient, githubMethod: GitHubMethod) => {
  const taskId = uuidv4();
  console.log(chalk.bold.cyan(`\n🚀 Starting Hikmapr Multi-Pass Analysis`));
  console.log(chalk.blue(`📝 Task ID: ${chalk.yellow(taskId)}`));
  console.log(chalk.blue(`🔗 PR URL: ${chalk.yellow(prUrl)}`));
  console.log(chalk.blue(`🔬 Using Advanced Multi-Pass Analysis Architecture`));

  // Use the advanced multi-pass analysis workflow
  const { app, config: workflowConfig } = getAppWithConfig();
  
  const methodInfo = '🔬 Multi-Pass Analysis: 4 specialized passes per chunk with hierarchical synthesis';
  console.log(chalk.gray(methodInfo));
  console.log(chalk.gray(`📋 Smart filtering → Recursive chunking → 4-pass analysis → Synthesis`));
  console.log(chalk.gray(`🔧 Workflow configured with recursion limit: ${workflowConfig.recursionLimit}`));

  const config = {
    configurable: {
      thread_id: taskId,
    },
    // Apply the workflow configuration to handle large number of files
    ...workflowConfig,
  };

  // Initial state
  const initialState = {
    pr_url: prUrl,
    task_id: taskId,
  };

  console.log(chalk.blue(`💾 Saving initial state to database...`));
  // Save initial state to the database
  await prisma.review.create({
    data: {
      id: taskId,
      prUrl: prUrl,
      state: initialState,
    },
  });
  console.log(chalk.green(`✅ Initial state saved`));

  let lastState: any = {};
  let currentSpinner: any = null;
  
  console.log(chalk.bold.magenta(`\n🔄 Starting workflow execution...\n`));
  
  try {
    for await (const event of await app.stream(initialState, config)) {
      // Fix: Access the state directly from the event
      const state = Object.values(event)[0] as any;
      
      // Properly merge analyzed_files to preserve all previous analyses
      const currentAnalyzedFiles = lastState.analyzed_files || {};
      const newAnalyzedFiles = state.analyzed_files || {};
      const mergedAnalyzedFiles = { ...currentAnalyzedFiles, ...newAnalyzedFiles };
      
      // Preserve accumulated state by merging with lastState
      lastState = { 
        ...lastState, 
        ...state,
        analyzed_files: mergedAnalyzedFiles
      };
      
      // Ensure analyzed_files is always an object to prevent Object.keys errors
      const analyzedFiles = state.analyzed_files || {};
      const filesToReview = state.files_to_review || [];
      
      // Save individual file analyses to database if new analyses are added
      if (state.analyzed_files && Object.keys(state.analyzed_files).length > 0) {
        for (const [fileName, analysis] of Object.entries(state.analyzed_files)) {
          // Check if this file analysis already exists to avoid duplicates
          const existingAnalysis = await prisma.fileAnalysis.findUnique({
            where: {
              reviewId_fileName: {
                reviewId: taskId,
                fileName: fileName
              }
            }
          });
          
          if (!existingAnalysis && typeof analysis === 'string') {
            console.log(chalk.gray(`💾 Saving file analysis for: ${fileName}`));
            await prisma.fileAnalysis.create({
              data: {
                reviewId: taskId,
                fileName: fileName,
                analysis: analysis,
                diffSize: analysis.length, // Store the analysis length as a proxy for diff size
              }
            });
            console.log(chalk.green(`✅ File analysis saved for: ${fileName}`));
          }
        }
      }
      
      // Update progress based on workflow state
      if(state.pr_details && !state.files_to_review) {
          if (currentSpinner) currentSpinner.succeed();
          console.log(chalk.green(`\n✅ PR Details fetched successfully`));
          currentSpinner = ora('Getting changed files list...').start();
      } else if (filesToReview.length > 0 && Object.keys(analyzedFiles).length === 0) {
          if (currentSpinner) currentSpinner.succeed();
          console.log(chalk.green(`\n✅ Found ${filesToReview.length} files to analyze`));
          console.log(chalk.blue(`📋 Files queue: ${filesToReview.join(', ')}`));
          
          // Show warning for large number of files
          if (filesToReview.length > 20) {
            console.log(chalk.yellow(`⚠️  Large number of files detected (${filesToReview.length}). This may take a while...`));
          }
          
          // Don't start spinner here - let the detailed logs show
      } else if (Object.keys(analyzedFiles).length > 0) {
          if (currentSpinner) currentSpinner.stop();
          const completed = Object.keys(analyzedFiles).length;
          const total = completed + filesToReview.length;
          console.log(chalk.cyan(`\n📈 Progress: ${completed}/${total} files analyzed`));
          
          if (filesToReview.length > 0) {
            console.log(chalk.blue(`🔄 Continuing with next file...`));
          } else {
            console.log(chalk.green(`🎯 All files analyzed, generating final report...`));
          }
      }

      console.log(chalk.gray(`💾 Updating database state...`));
      // Update state in DB with accumulated state to preserve all file analyses
      await prisma.review.update({
        where: { id: taskId },
        data: { state: lastState },
      });
    }
  } catch (error: any) {
    if (currentSpinner) currentSpinner.fail();
    
    // Handle recursion limit error specifically
    if (error.lc_error_code === 'GRAPH_RECURSION_LIMIT') {
      console.error(chalk.red(`\n❌ Workflow hit recursion limit while processing files.`));
      console.error(chalk.yellow(`🔧 This usually happens with a large number of files (${Object.keys(lastState.analyzed_files || {}).length} files processed so far).`));
      console.error(chalk.blue(`💡 Consider breaking down the PR into smaller commits or contact support.`));
      console.error(chalk.gray(`📋 Files already analyzed: ${Object.keys(lastState.analyzed_files || {}).join(', ')}`));
      console.error(chalk.gray(`📋 Files remaining: ${(lastState.files_to_review || []).join(', ')}`));
    } else {
      console.error(chalk.red(`\n❌ Error during review process: ${error.message || error}`));
    }
    
    // Save the current state even on error
    try {
      await prisma.review.update({
        where: { id: taskId },
        data: { 
          state: lastState,
          error: error.message || String(error)
        },
      });
    } catch (dbError) {
      console.error(chalk.red(`❌ Additional error saving state to database: ${dbError}`));
    }
    
    return; // Exit early on error
  }

  if (currentSpinner) currentSpinner.succeed();
  
  console.log(chalk.bold.green(`\n🎉 Analysis Complete!`));
  console.log(chalk.blue(`⏱️  Task ID for future reference: ${chalk.yellow(taskId)}`));
  
  // Show file analysis database summary
  try {
    const fileAnalysisCount = await prisma.fileAnalysis.count({
      where: { reviewId: taskId }
    });
    console.log(chalk.blue(`💾 Individual file analyses saved to database: ${chalk.yellow(fileAnalysisCount)}`));
    console.log(chalk.gray(`💡 View file analyses: ${chalk.cyan(`hikma reports files ${taskId}`)}`));
  } catch (error) {
    console.log(chalk.yellow(`⚠️  Could not verify file analysis count in database`));
  }
  
  // Generate and save markdown report
  console.log(chalk.blue(`\n📄 Generating markdown report...`));
  try {
    const markdown = generateMarkdownReport(lastState, taskId, prUrl);
    const reportPath = saveMarkdownReport(markdown, prUrl, taskId);
    console.log(chalk.green(`✅ Report saved to: ${chalk.yellow(reportPath)}`));
    
    // Show relative path for easier access
    const relativePath = path.relative(process.cwd(), reportPath);
    console.log(chalk.blue(`📝 View your report: ${chalk.cyan(`cat "${relativePath}"`)}`));
    console.log(chalk.blue(`🔗 Or open in editor: ${chalk.cyan(`code "${relativePath}"`)}`));
  } catch (error) {
    console.error(chalk.red(`❌ Error saving markdown report: ${error}`));
  }
  
  console.log(chalk.bold.magenta('\n' + '='.repeat(60)));
  console.log(chalk.bold.magenta('📊 HIKMAPR PR REVIEW REPORT'));
  console.log(chalk.bold.magenta('='.repeat(60)));
  console.log(lastState.final_report);
  console.log(chalk.bold.magenta('='.repeat(60)));
};
